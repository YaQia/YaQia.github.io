# Introduction

在尝试实现分布式系统前，先试试单机能否实现，单机实现永远是更简单的。

为什么要分布式系统：

- 想提高并发度
- 想实现容错
- 物理原因（例如银行等机构合作的跨域机器间要保持连接和计算）
- 安全性/隔离性（有些资源不想让其他机器看到）

分布式系统的困难/挑战：

- 并发要如何保证数据正确性
- partial failure（部分机器出错，不是所有）
- 性能提升空间很大（搜索空间大，最优解可能永远都找不到）

## Infrastructure & Abstractions

在分布式系统中最关注的基础设施有：

- 存储（最重要，需要设计和实现的部分）
- 通信（依赖特性，一般不会设计其中的内容）
- 计算（也是设计的一部分）

目标：
发现抽象，简化计算与存储，隐藏系统的分布式特性，让应用程序开发者就像在开发单机程序一样无感开发

很难看到计算和存储抽象能和非分布式存储版本拥有一样的性质，但这正是我们需要尝试达到的

## Implementation（需要用到的工具）

- RPC
- threads
- concurrency control (e.g. locks)

## Perfromance

- Scalability: n倍的计算机 -> n倍的吞吐量
  > [!TIP]
  > 有限的可扩展性对于一些应用是很好实现的（nginx可以将流量均摊到多个服务器上），但对于存储系统（如数据库）来说是非常困难的
- Fault Tolerance: 1000台计算机不可能都稳定运行持续1年，可能1天就会有3台发生故障
  - Availability: 即使出现某种故障（特定故障，不是所有故障），系统还能持续运行
  - Recoverability: 系统可能故障了，但只要得到修复，就可以像没有故障一样继续运行（要求比Availability低，只要系统能重启就好）
    > [!TIP]
    > 常见的实现容错性的方法有：
    > 1. 用非易失性存储器(NV Storage)来实现这个功能
    > 2. 用副本(Replication)来达到这个效果

## Consistency

拿到的数据应该满足某种一致性协议

> [!NOTE]
> 例如分布式的`Put(k, v)`和`Get(k) -> v`，因为有多个副本，这两个API有可能会产生歧义
>
> 如果`Put(1, 21)`发给了一个分布式KV存储，而因为某种错误，另外一个存储副本并没有更新
>
> 这时你的`Get(1)`就不确定究竟会返回哪一个值了

- strong consistency: 数据保证强一致性，也就带来了高的性能开销
- weak consistency: 数据保证弱一致性，那么该怎么定义这个一致性协议是最大的问题
